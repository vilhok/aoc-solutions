package solutions.year2021;

import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day17 extends DayX {

	String regex = "target area: x=(.*)\\.\\.(.*), y=(.*)\\.\\.(.*)";

	class Probe {
		int xposition;
		int yposition;

		int xvelocity;
		int yvelocity;

		int highest;

		public Probe(int xvelocity, int yvelocity) {
			this.xvelocity = xvelocity;
			this.yvelocity = yvelocity;
		}

		public void update() {
			xposition += xvelocity;
			yposition += yvelocity;
			if (xvelocity != 0)
				xvelocity--;
			if (yposition > highest) {
				highest = yposition;
			}
			yvelocity--;
		}

		public boolean inside(int x, int x2, int y, int y2) {
			return xposition >= x && xposition <= x2 && yposition >= y && yposition <= y2;
		}

		public boolean past(int x2, int y2) {
			return xposition > x2 || yposition <= y2;
		}

	}

	@Override
	public Object firstPart(InputParser input) {
		String area = input.string();
		Matcher m = Pattern.compile(regex).matcher(area);

		m.matches();
		int minx = Integer.parseInt(m.group(1));
		int maxx = Integer.parseInt(m.group(2));

		int miny = Integer.parseInt(m.group(3));
		int maxy = Integer.parseInt(m.group(4));

		int result = 0;
		for (int x = 0; x < maxx; x++) {
			// TODO: I'd like to figure out a way to not guess the y.
			for (int y = miny; y < 200; y++) {
				Probe p = new Probe(x, y);
				int highest = p.yposition;
				while (!p.inside(minx, maxx, miny, maxy) && !p.past(maxx, miny)) {
					p.update();
					if (p.yposition > highest)
						highest = p.yposition;
				}
				if (p.inside(minx, maxx, miny, maxy) && highest > result) {
					result = highest;
				}

			}
		}

		return result;
	}

	@Override
	public Object secondPart(InputParser input) {
		String area = input.string();
		Matcher m = Pattern.compile(regex).matcher(area);

		m.matches();
		int minx = Integer.parseInt(m.group(1));
		int maxx = Integer.parseInt(m.group(2));

		int miny = Integer.parseInt(m.group(3));
		int maxy = Integer.parseInt(m.group(4));

		int count = 0;

		for (int x = 0; x <= maxx; x++) {

			for (int y = miny; y < 200; y++) {
				Probe p = new Probe(x, y);
				while (!p.inside(minx, maxx, miny, maxy) && !p.past(maxx, miny)) {
					p.update();
				}

				if (p.inside(minx, maxx, miny, maxy)) {
					count++;
				}

			}
		}
		return count;

	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("target area: x=20..30, y=-10..-5", 45));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("target area: x=20..30, y=-10..-5", 112));
	}
}
