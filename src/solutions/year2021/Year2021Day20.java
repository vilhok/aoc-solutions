package solutions.year2021;

import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

import utils.Point;
import utils.Utils;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day20 extends DayX {

	private long enchance(InputParser input, int rounds) {
		List<List<String>> groups = input.getGroups();
		String algorithm = groups.get(0).get(0);

		List<String> data = groups.get(1);

		HashMap<Point, Integer> map = new HashMap<>();

		for (int i = 0; i < data.size(); i++) {
			String row = data.get(i);
			for (int j = 0; j < row.length(); j++) {
				Point p = new Point(j, i);
				int c = row.charAt(j) == '#' ? 1 : 0;
				map.put(p, c);
			}
		}

		final int originalMinX = -1;
		final int originalMaxX = data.get(0).length();
		final int originalMinY = -1;
		final int originalMaxY = data.size();

		// the range should have twice as much extra.
		// because 000000000 turns to '#', the borders are filled by gibberish
		// for having 'rounds' as much extra around the borders, after simulating
		// 'rounds' many rounds, the gibberish has propagated to the border of the
		// actual zone.
		// this gibberish is later removed
		int minx = originalMinX - rounds * 2;
		int miny = originalMinY - rounds * 2;
		int maxx = originalMaxX + rounds * 2;
		int maxy = originalMaxY + rounds * 2;
		for (int i = 0; i < rounds; i++) {
			HashMap<Point, Integer> updatedmap = new HashMap<>();

			for (int x = minx; x <= maxx; x++) {
				for (int y = miny; y <= maxy; y++) {
					Point p = new Point(x, y);
					List<Point> nine = Utils.nineNeighbors();

					StringBuilder sb = new StringBuilder();
					for (Point neighbor : nine) {
						sb.append(map.getOrDefault(p.add(neighbor), 0));
					}

					int index = Integer.parseInt(sb.toString(), 2);

					updatedmap.put(p, algorithm.charAt(index) == '#' ? 1 : 0);
				}
			}
			map = updatedmap;
		}

		cleanMap(map, originalMinX - rounds, originalMaxX + rounds, originalMinY - rounds, originalMaxY + rounds);

		return map.values().stream().filter(i -> i == 1).count();
	}

	private void cleanMap(HashMap<Point, Integer> map, int minx, int maxx, int miny, int maxy) {

		for (Point p : map.keySet()) {
			if (p.x() < minx || p.y() < miny || p.y() > maxy || p.x() > maxx) {
				map.put(p, 0);
			}
		}
	}

	String nextfile = "output.txt";

	private void printMap(HashMap<Point, Integer> map, int minx, int miny, int maxx, int maxy, boolean file) {
		String path = "0" + nextfile;
		nextfile = path;
		FileWriter fw = null;
		try {
			if (file)
				fw = new FileWriter(path);

			for (int x = minx; x <= maxx; x++) {
				for (int y = miny; y <= maxy; y++) {
					Point p = new Point(x, y);
					if (file)
						fw.write(map.getOrDefault(p, 0) == 1 ? '#' : '.');
					System.out.print(map.getOrDefault(p, 0) == 1 ? '#' : '.');
				}
				if (file)
					fw.write("\n");
				System.out.println();
			}
			if (file)
				fw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public Object firstPart(InputParser input) {
		return enchance(input, 2);
	}

	@Override
	public Object secondPart(InputParser input) {
		return enchance(input, 50);
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test(t1data, 35));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test(t1data, 3351));
	}

	String t1data = """
			..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#

			#..#.
			#....
			##..#
			..#..
			..###""";
}
