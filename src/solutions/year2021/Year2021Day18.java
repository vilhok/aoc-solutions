package solutions.year2021;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day18 extends DayX {

	@SuppressWarnings("serial")
	class SnailFishNumber extends Number {

		private SnailFishNumber parent;

		private Number left;
		private Number right;

		private ArrayList<String> originalParseData;

		public SnailFishNumber(Number left, Number right) {
			this.left = left;
			this.right = right;
			if (left instanceof SnailFishNumber s) {
				s.parent = this;
			}
			if (right instanceof SnailFishNumber s) {
				s.parent = this;
			}
		}

		public SnailFishNumber() {

		}

		public SnailFishNumber copy() {
			SnailFishNumber s = new SnailFishNumber();
			s.parse(new ArrayDeque<>(originalParseData));
			return s;
		}

		public SnailFishNumber parse(ArrayDeque<String> s) {
			this.originalParseData = new ArrayList<>(s);
			left = parseNext(s, this);
			while (s.peek().equals("]"))
				s.poll();
			right = parseNext(s, this);
			return this;
		}

		private Number parseNext(ArrayDeque<String> s, SnailFishNumber parent) {
			String elem = s.poll();
			if (elem.equals("[")) {
				return new SnailFishNumber().setParent(parent).parse(s);
			} else {
				return Long.parseLong(elem);
			}
		}

		public SnailFishNumber add(Number n) {
			return new SnailFishNumber(this, n);
		}

		public SnailFishNumber setParent(SnailFishNumber s) {
			this.parent = s;
			return this;
		}

		public boolean split() {
			boolean leftsplit = false;
			if (!(left instanceof SnailFishNumber)) {
				long val = left.longValue();
				if (val >= 10) {
					long leftNum = val / 2;
					long rightNum = val - leftNum;
					left = new SnailFishNumber(leftNum, rightNum).setParent(this);
					return true;
				}
			} else {
				leftsplit = ((SnailFishNumber) left).split();
			}
			if (leftsplit)
				return leftsplit;

			if (!(right instanceof SnailFishNumber)) {
				long val = right.longValue();
				if (val >= 10) {
					long leftNum = val / 2;
					long rightNum = val - leftNum;
					right = new SnailFishNumber(leftNum, rightNum).setParent(this);
					return true;
				}
				return false;
			} else {
				return ((SnailFishNumber) right).split();

			}

		}

		public boolean explode() {
			return this.explode(1, this);

		}

		/**
		 * Explodes a node where depth is 5.
		 * 
		 * If depth is less, explode left and right node if possible
		 * 
		 * @param depth
		 * @param parent who does this belong to.
		 * @return
		 */
		private boolean explode(int depth, SnailFishNumber parent) {
			if (depth == 5) {
				parent.transferLeftUp(left.longValue(), this);
				parent.transferRightUp(right.longValue(), this);
				if (this == parent.left) {
					parent.left = 0;
				} else {
					parent.right = 0;
				}
				return true;
			}

			boolean leftExplode = false;
			if (left instanceof SnailFishNumber l) {
				leftExplode = l.explode(depth + 1, this);
			}
			if (leftExplode)
				return true;
			if (right instanceof SnailFishNumber r) {
				return r.explode(depth + 1, this);
			}

			return false;
		}

		public void transferRightUp(long value, SnailFishNumber child) {
			// keep going up if we have a parent
			if (child == this.right) {
				if (parent != null) {
					this.parent.transferRightUp(value, this);
				}
				// no parent, we arrived at root, the value is discarded

				// We were travelling right, but at this time we came back from the left node.
				// this means we can start to travel down and left, from the right hand side
			} else if (this.right instanceof SnailFishNumber rightBranch) {
				rightBranch.travelLeftDown(value);
			} else {
				// if the right hand side a regular number, so we can directly set a value
				this.right = this.right.intValue() + value;
			}
		}

		public void transferLeftUp(long value, SnailFishNumber child) {
			if (child == this.left) {
				// keep going up if we have a parent
				if (parent != null)
					this.parent.transferLeftUp(value, this);
			} else if (this.left instanceof SnailFishNumber leftBranch) {
				leftBranch.transferRightDown(value);
			} else {
				this.left = this.left.intValue() + value;
			}
		}

		public void transferRightDown(long value) {
			if (this.right instanceof SnailFishNumber rightBranch) {
				rightBranch.transferRightDown(value);
			} else {
				this.right = this.right.intValue() + value;
			}
		}

		public void travelLeftDown(long value) {
			if (this.left instanceof SnailFishNumber rightBranch) {
				rightBranch.travelLeftDown(value);
			} else {
				this.left = this.left.intValue() + value;
			}
		}

		public void reduce() {
			while (true) {
				boolean ex = this.explode();

				if (ex) {
					continue;
				}
				boolean sp = this.split();
				if (sp) {

					continue;
				}
				break;
			}
		}

		@Override
		public String toString() {
			return "[" + left + "," + right + "]";
		}

		@Override
		public int intValue() {
			return (int) longValue();
		}

		/**
		 * Represents the magnitude of this snailfish number.
		 */
		@Override
		public long longValue() {
			return left.longValue() * 3 + right.longValue() * 2;
		}

		@Override
		public float floatValue() {
			return longValue();
		}

		@Override
		public double doubleValue() {
			return longValue();
		}

	}

	@Override
	public Object firstPart(InputParser input) {
		ArrayList<SnailFishNumber> nums = input.getLines(this::parseNumber, new ArrayList<SnailFishNumber>());
		SnailFishNumber base = nums.remove(0);
		for (SnailFishNumber number : nums) {
			base = base.add(number);
			base.reduce();
		}
		return base.longValue();
	}

	public SnailFishNumber parseNumber(String s) {
		ArrayList<String> chars = new ArrayList<>(List.of(s.split("")));
		ArrayDeque<String> tokens = new ArrayDeque<String>();

		while (!chars.isEmpty()) {
			String next = chars.remove(0);
			if (next.equals("]") | next.equals("[")) {
				tokens.add(next);
			} else if (next.matches("[0-9]")) {
				while (chars.get(0).matches("[0-9]")) {
					next += chars.remove(0);
				}
				tokens.add(next);
			}
		}
		tokens.poll(); // omit the first [
		SnailFishNumber sfn = new SnailFishNumber();
		sfn.parse(tokens);
		return sfn;
	}

	@Override
	public Object secondPart(InputParser input) {
		ArrayList<SnailFishNumber> nums = input.getLines(this::parseNumber, new ArrayList<SnailFishNumber>());

		long largest = 0;

		for (SnailFishNumber a : nums) {
			for (SnailFishNumber b : nums) {
				if (a == b)
					continue;
				SnailFishNumber n = a.copy().add(b.copy());
				n.reduce();
				long m = n.longValue();
				if (m > largest)
					largest = m;
			}
		}
		return largest;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("[9,1]", 29));
		tests.add(new Test("[[1,2],[[3,4],5]]", 143));
		tests.add(new Test("[[[[0,7],4],[[7,8],[6,0]]],[8,1]]", 1384));
		tests.add(new Test("[[[[1,1],[2,2]],[3,3]],[4,4]]", 445));
		tests.add(new Test("[[[[5,0],[7,4]],[5,5]],[6,6]]", 1137));
		tests.add(new Test("[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]", 3488));
		tests.add(new Test("""
				[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
				[[[5,[2,8]],4],[5,[[9,9],0]]]
				[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
				[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
				[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
				[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
				[[[[5,4],[7,7]],8],[[8,3],8]]
				[[9,3],[[9,9],[6,[4,9]]]]
				[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
				[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]""", 4140));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("""
				[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]
				[[[5,[2,8]],4],[5,[[9,9],0]]]
				[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]
				[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]
				[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]
				[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]
				[[[[5,4],[7,7]],8],[[8,3],8]]
				[[9,3],[[9,9],[6,[4,9]]]]
				[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]
				[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]
						""", 3993));
	}
}
