package solutions.year2021;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day10 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		List<String> lines = input.getLines();
		int totalErr = 0;
		for (String s : lines) {
			ArrayDeque<Character> stack = new ArrayDeque<>();
			currentLine:
			for (char c : s.toCharArray()) {
				switch (c) {
				case '(':
				case '[':
				case '{':
				case '<':
					stack.push(c);
					break;
				case ')':
					if (stack.peek() == '(') {
						stack.pop();
					} else {
						totalErr += 3;
						break currentLine;
					}
					break;
				case ']':
					if (stack.peek() == '[') {
						stack.pop();
					} else {
						totalErr += 57;
						break currentLine;
					}
					break;
				case '}':
					if (stack.peek() == '{') {
						stack.pop();
					} else {
						totalErr += 1197;
						break currentLine;
					}
					break;
				case '>':
					if (stack.peek() == '<') {
						stack.pop();
					} else {
						totalErr += 25137;
						break currentLine;
					}
					break;

				default:
					throw new IllegalArgumentException("Unexpected value: " + c);
				}
			}
		}
		return totalErr;
	}

	@Override
	public Object secondPart(InputParser input) {
		List<String> lines = input.getLines();
		ArrayList<Long> incomplete = new ArrayList<>();
		nextLine:
		for (String s : lines) {
			ArrayDeque<Character> stack = new ArrayDeque<>();
			for (char c : s.toCharArray()) {
				switch (c) {
				case '(':
				case '[':
				case '{':
				case '<':
					stack.push(c);
					break;
				case ')':
					if (stack.peek() == '(') {
						stack.pop();
					} else {
						continue nextLine;
					}
					break;
				case ']':
					if (stack.peek() == '[') {
						stack.pop();
					} else {
						continue nextLine;
					}
					break;
				case '}':
					if (stack.peek() == '{') {
						stack.pop();
					} else {
						continue nextLine;
					}
					break;
				case '>':
					if (stack.peek() == '<') {
						stack.pop();
					} else {
						continue nextLine;
					}
					break;
				}
			}

			long score = 0;
			while (stack.size() != 0) {
				char c = stack.pop();
				score *= 5;
				score += switch (c) {
				case '(' -> 1;
				case '[' -> 2;
				case '{' -> 3;
				case '<' -> 4;
				default -> 0;
				};
			}
			incomplete.add(score);

		}
		Collections.sort(incomplete);
		return incomplete.get(incomplete.size() / 2);
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("()", 0));
		tests.add(new Test("(]", 57));
		tests.add(new Test("[<>({}){}[([])<>]]", 0));
		tests.add(new Test("[({(<(())[]>[[{[]{<()<>>\n" + "[(()[<>])]({[<{<<[]>>(\n" + "{([(<{}[<>[]}>{[]{[(<()>\n"
				+ "(((({<>}<{<{<>}{[]{[]{}\n" + "[[<[([]))<([[{}[[()]]]\n" + "[{[{({}]{}}([{[{{{}}([]\n"
				+ "{<[[]]>}<{[{[{[]{()[[[]\n" + "[<(<(<(<{}))><([]([]()\n" + "<{([([[(<>()){}]>(<<{{\n"
				+ "<{([{{}}[<[[[<>{}]]]>[]]", 26397));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("[({(<(())[]>[[{[]{<()<>>\n" + "[(()[<>])]({[<{<<[]>>(\n" + "{([(<{}[<>[]}>{[]{[(<()>\n"
				+ "(((({<>}<{<{<>}{[]{[]{}\n" + "[[<[([]))<([[{}[[()]]]\n" + "[{[{({}]{}}([{[{{{}}([]\n"
				+ "{<[[]]>}<{[{[{[]{()[[[]\n" + "[<(<(<(<{}))><([]([]()\n" + "<{([([[(<>()){}]>(<<{{\n"
				+ "<{([{{}}[<[[[<>{}]]]>[]]", 288957));

	}
}
