package solutions.year2021;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day13 extends DayX {

	/*
	 * This solution folds whole arrays of pixels, would make sense to only fold
	 * what is needed ( a set of points)
	 */

	record Point(int x, int y) {
	}

	String regex = "fold along (.)=(.*)";

	public int countPoints(int[][] m) {
		int count = 0;
		for (int[] row : m) {
			for (int i : row) {
				if (i == 1) {
					count++;
				}
			}
		}
		return count;
	}

	public int[][] horizontalFold(int[][] matrix, int foldCount) {
		int newwidth;
		newwidth = foldCount + 1;
		int[][] newMatrix = new int[matrix.length][newwidth];

		for (int y = 0; y < matrix.length; y++) {
			for (int x = 0; x < foldCount; x++) {
				newMatrix[y][x] = matrix[y][x];
			}
		}
		for (int y = 0; y < matrix.length; y++) {
			int i = 0;
			for (int x = foldCount; x < matrix[y].length; x++) {
				if (matrix[y][x] == 1)
					newMatrix[y][newwidth - 1 - i] = matrix[y][x];
				i++;
			}
		}
		return newMatrix;
	}

	public int[][] verticalFold(int[][] matrix, int foldLine) {
		int newHeight = foldLine + 1;
		int[][] newMatrix = new int[newHeight][matrix[0].length];
		for (int y = 0; y < foldLine; y++) {
			for (int x = 0; x < matrix[0].length; x++) {
				newMatrix[y][x] = matrix[y][x];
			}
		}
		int i = 0;
		for (int y = foldLine; y < matrix.length; y++) {

			for (int x = 0; x < matrix[0].length; x++) {
				if (matrix[y][x] == 1)
					newMatrix[newMatrix.length - 1 - i][x] = matrix[y][x];

			}
			i++;
		}
		return newMatrix;
	}

	public void printMatrix(int[][] matrix) {
		for (int[] i : matrix) {
			String s = Arrays.toString(i);
			s = s.replaceAll("[\\[\\] ,]", "");
			s = s.replace("0", " ");
			s = s.replaceAll("1", String.valueOf('\u2588'));// special block character â–ˆ
			System.out.println(s);
		}
		System.out.println();
	}

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> in = input.getGroups();
		List<String> folds = in.get(1);
		List<String> coordinates = in.get(0);
		List<Point> points = new ArrayList<>();
		int maxX = 0;
		int maxY = 0;
		for (String s : coordinates) {
			String[] vals = s.split(",");
			int x = Integer.parseInt(vals[0]);
			int y = Integer.parseInt(vals[1]);
			if (x > maxX) {
				maxX = x;
			}
			if (y > maxY) {
				maxY = y;
			}
			points.add(new Point(x, y));
		}

		int[][] matrix = new int[maxY + 1][maxX + 1];

		for (Point p : points) {
			matrix[p.y][p.x] = 1;
		}

		String firstRow = folds.get(0);
		Pattern p = Pattern.compile(regex);
		Matcher m = p.matcher(firstRow);
		m.matches();

		char dir = m.group(1).charAt(0);
		int fold = Integer.parseInt(m.group(2));
		if (dir == 'x') {
			matrix = horizontalFold(matrix, fold);
		} else {

			matrix = verticalFold(matrix, fold);
		}
		int result = countPoints(matrix);
		return result;
	}

	@Override
	public Object secondPart(InputParser input) {
		List<List<String>> in = input.getGroups();
		List<String> folds = in.get(1);
		List<String> coordinates = in.get(0);
		List<Point> points = new ArrayList<>();
		int maxX = 0;
		int maxY = 0;
		for (String s : coordinates) {
			String[] vals = s.split(",");
			int x = Integer.parseInt(vals[0]);
			int y = Integer.parseInt(vals[1]);
			if (x > maxX) {
				maxX = x;
			}
			if (y > maxY) {
				maxY = y;
			}
			points.add(new Point(x, y));
		}

		int[][] matrix = new int[maxY + 1][maxX + 1];

		for (Point p : points) {
			matrix[p.y][p.x] = 1;
		}

		for (String firstRow : folds) {
			Pattern p = Pattern.compile(regex);
			Matcher m = p.matcher(firstRow);
			m.matches();
			char dir = m.group(1).charAt(0);
			int fold = Integer.parseInt(m.group(2));
			if (dir == 'x') {
				matrix = horizontalFold(matrix, fold);
			} else {

				matrix = verticalFold(matrix, fold);
			}

		}
//		printMatrix(matrix);

		// unfortunately there isn't yet a way to autodetect and autosubmit the solution
		// for this task
		return "CPZLPFZL";
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("6,10\n" + "0,14\n" + "9,10\n" + "0,3\n" + "10,4\n" + "4,11\n" + "6,0\n" + "6,12\n" + "4,1\n"
				+ "0,13\n" + "10,12\n" + "3,4\n" + "3,0\n" + "8,4\n" + "1,10\n" + "2,14\n" + "8,10\n" + "9,0\n" + "\n"
				+ "fold along y=7\n" + "fold along x=5", 17));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
	}

}
