package solutions.year2021;

import java.util.Arrays;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day11 extends DayX {

	@Override
	public Object firstPart(InputParser input){
		int[][] octopi = input.intMatrix();
		int total = 0;
		for (int i = 0; i < 100; i++) {
			System.out.println("step " + (i + 1));
			// increment
			for (int[] row : octopi) {
				for (int j = 0; j < row.length; j++) {
					row[j]++;
				}

			}
			total += resolveFlashes(octopi, new boolean[10][10]);
			nollaa(octopi);
		}

		return total;
	}

	private void nollaa(int[][] octopi){

		for (int[] row : octopi) {
			for (int i = 0; i < row.length; i++) {
				if (row[i] > 9) {
					row[i] = 0;
				}
			}
		}
	}

	private int resolveFlashes(int[][] octopi, boolean[][] flashmap){
		int flashed = 0;

		for (int i = 0; i < octopi.length; i++) {
			for (int j = 0; j < octopi.length; j++) {
				if (octopi[i][j] > 9 && !flashmap[i][j]) {
					flashed++;
					if (i > 0) {
						octopi[i - 1][j]++;
					}
					if (j > 0) {
						octopi[i][j - 1]++;
					}
					if (i < octopi.length - 1) {
						octopi[i + 1][j]++;
					}
					if (j < octopi[0].length - 1) {
						octopi[i][j + 1]++;
					}

					if (i > 0 && j > 0) {
						octopi[i - 1][j - 1]++;
					}
					if (i > 0 && j < octopi.length - 1) {
						octopi[i - 1][j + 1]++;
					}
					if (j > 0 && i < octopi.length - 1) {
						octopi[i + 1][j - 1]++;
					}
					if (i < octopi.length - 1 && j < octopi[0].length - 1) {
						octopi[i + 1][j + 1]++;
					}
					flashmap[i][j] = true;
				}
			}
		}
		if (flashed > 0) {
			flashed += resolveFlashes(octopi, flashmap);
		}
		return flashed;
	}

	@Override
	public Object secondPart(InputParser input){
		int[][] octopi = input.intMatrix();
		int step = 0;
		for (int i = 0; i < 10000000; i++) {
			System.out.println("step " + (i + 1));
			// increment
			for (int[] row : octopi) {
				for (int j = 0; j < row.length; j++) {
					row[j]++;
				}

			}
			boolean[][] cache = new boolean[10][10];

			resolveFlashes(octopi, cache);
			boolean all = true;
			for (boolean[] row : cache) {
				for (int j = 0; j < row.length; j++) {
					if (!row[j]) {
						all = false;
						break;
					}
				}

			}
			if (all) {
				step = i+1;
				break;
			}

			nollaa(octopi);
		}

		return step;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests){
//		tests.add(new Test("11111\n" + "19991\n" + "19191\n" + "19991\n" + "11111", 0));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests){

	}
}
