package solutions.year2021;

import java.util.Arrays;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day11 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		int[][] octopuses = input.intMatrix();
		int totalFlashes = 0;
		for (int i = 0; i < 100; i++) {
			for (int[] row : octopuses) {
				for (int j = 0; j < row.length; j++) {
					row[j]++;
				}

			}
			totalFlashes += resolveFlashes(octopuses, new boolean[10][10]);
			resetFlashed(octopuses);
		}

		return totalFlashes;
	}

	private void resetFlashed(int[][] octopuses) {
		for (int[] row : octopuses) {
			for (int i = 0; i < row.length; i++) {
				if (row[i] > 9) {
					row[i] = 0;
				}
			}
		}
	}

	private int resolveFlashes(int[][] octopuses, boolean[][] flashmap) {
		int flashed = 0;

		for (int i = 0; i < octopuses.length; i++) {
			for (int j = 0; j < octopuses.length; j++) {
				if (octopuses[i][j] > 9 && !flashmap[i][j]) {
					flashed++;
					if (i > 0) {
						octopuses[i - 1][j]++;
					}
					if (j > 0) {
						octopuses[i][j - 1]++;
					}
					if (i < octopuses.length - 1) {
						octopuses[i + 1][j]++;
					}
					if (j < octopuses[0].length - 1) {
						octopuses[i][j + 1]++;
					}

					if (i > 0 && j > 0) {
						octopuses[i - 1][j - 1]++;
					}
					if (i > 0 && j < octopuses.length - 1) {
						octopuses[i - 1][j + 1]++;
					}
					if (j > 0 && i < octopuses.length - 1) {
						octopuses[i + 1][j - 1]++;
					}
					if (i < octopuses.length - 1 && j < octopuses[0].length - 1) {
						octopuses[i + 1][j + 1]++;
					}
					flashmap[i][j] = true;
				}
			}
		}
		if (flashed > 0) {
			flashed += resolveFlashes(octopuses, flashmap);
		}
		return flashed;
	}

	@Override
	public Object secondPart(InputParser input) {
		int[][] octopuses = input.intMatrix();
		int step = 0;
		while (true) {
			// increment
			for (int[] row : octopuses) {
				for (int j = 0; j < row.length; j++) {
					row[j]++;
				}

			}
			boolean[][] cache = new boolean[10][10];

			resolveFlashes(octopuses, cache);
			boolean all = true;
			for (boolean[] row : cache) {
				for (int j = 0; j < row.length; j++) {
					if (!row[j]) {
						all = false;
						break;
					}
				}

			}
			step++;
			if (all) {
				break;
			}

			resetFlashed(octopuses);
		}

		return step;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
//		tests.add(new Test("11111\n" + "19991\n" + "19191\n" + "19991\n" + "11111", 0));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {

	}
}
