package solutions.year2021;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day14 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		HashMap<Iteration, HashMap<Character, Long>> map = new HashMap<>();

		HashMap<Character, Long> result = recursePolymerPair(map, polymerReplace, polymerTemplate.toString(), 10);

		char c = polymerTemplate.charAt(0);
		long s = result.get(c);
		result.put(c, s + 1);

		ArrayList<Long> longs = new ArrayList<>(result.values());
		Collections.sort(longs);
		System.out.println(longs);

		return longs.get(longs.size() - 1) - longs.get(0);

	}

	private Object originalPart1(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		record Insert(int index, String value) implements Comparable<Insert> {

			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		for (int i = 0; i < 10; i++) {
			ArrayList<Insert> inserts = new ArrayList<>();

			for (String s : polymerReplace.keySet()) {
				int startIndex = 0;
				do {
					int next = polymerTemplate.indexOf(s, startIndex);
					if (next != -1) {
						inserts.add(new Insert(next + 1, polymerReplace.get(s)));
						startIndex = next + 1;
					} else {
						startIndex = next;
					}

				} while (startIndex != -1);
			}

			Collections.sort(inserts, Collections.reverseOrder());
//			System.out.println("before: " + polymerTemplate);
			for (Insert ch : inserts) {
				polymerTemplate.insert(ch.index, ch.value);
//				System.out.println(ch);
			}
//			System.out.println("after:  " + polymerTemplate);

		}
		return getCount(polymerTemplate);
	}

	private long getCount(StringBuilder polymerTemplate) {
		ArrayList<Integer> counts = new ArrayList<>();

		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i).collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			int count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}
			counts.add(count);
		}

		Collections.sort(counts);
		return counts.get(counts.size() - 1) - counts.get(0);

	}

	private HashMap<Character, Long> getCounts(String polymerTemplate) {
		HashMap<Character, Long> map = new HashMap<>();
		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i).collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			long count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}

			map.put(c, count);
		}

		return map;

	}

	record Iteration(String polymer, Integer afterNrounds) {

	}

	public void insertPolymers(StringBuilder og, HashMap<String, String> polymerReplace) {
		record Insert(int index, String value) implements Comparable<Insert> {

			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		ArrayList<Insert> inserts = new ArrayList<>();

		for (String s : polymerReplace.keySet()) {
			int startIndex = 0;
			do {
				int next = og.indexOf(s, startIndex);
				if (next != -1) {
					inserts.add(new Insert(next + 1, polymerReplace.get(s)));
					startIndex = next + 1;
				} else {
					startIndex = next;
				}

			} while (startIndex != -1);
		}

		Collections.sort(inserts, Collections.reverseOrder());
//		System.out.println("before: " + og);
		for (Insert ch : inserts) {
			og.insert(ch.index, ch.value);
//			System.out.println(ch);
		}
//		System.out.println("after:  " + og);
	}

	public HashMap<Character, Long> recursePolymerPair(HashMap<Iteration, HashMap<Character, Long>> map,
			HashMap<String, String> inserts, String polymer, int round) {
		Iteration piece = new Iteration(polymer, round);

		if (map.containsKey(piece)) {
//			System.out.println("We have " + piece + " returning..");
			return map.get(piece);
		} else {
//			System.out.println("No "+piece +" available. Calculating..");
		}

		if (round == 1) {
			StringBuilder finalPoly = new StringBuilder(polymer);
			finalPoly.insert(1, inserts.get(polymer));
			HashMap<Character, Long> h = getCounts(finalPoly.substring(1));
//			System.out.println("final level, saving!");
//			System.out.println(piece + " " + h + " " + finalPoly);
			map.put(piece, h);
			return h;

		}
		round--;
		StringBuilder poly = new StringBuilder(polymer);
		insertPolymers(poly, inserts);
//		System.out.println(" Reacted result:" + poly + " iterating...");
		HashMap<Character, Long> finalCounts = new HashMap<Character, Long>();

		for (int i = 0; i < poly.length() - 1; i++) {
			String s = poly.substring(i, i + 2);

			Iteration segment = new Iteration(s, round);
//			System.out.println("subsegment:" + s);
			if (map.containsKey(segment)) {
//				System.out.println("This count was known");
//				System.out.println(map.get(segment));
			} else {
				HashMap<Character, Long> ch = recursePolymerPair(map, inserts, s, round);
//				System.out.println("piece " + segment + " completed: "+ch);
				map.put(segment, ch);

			}
			mergeMaps(finalCounts, map.get(segment));
//			System.out.println("Subpolymer " + s + " has result " + finalCounts);
		}
//		System.out.println("Polymer " + polymer + " done.");
		return finalCounts;
	}

	private void mergeMaps(HashMap<Character, Long> destination, HashMap<Character, Long> source) {

		for (Character c : source.keySet()) {
			Long count = source.get(c);
			Long original = destination.getOrDefault(c, 0L);
			destination.put(c, count + original);
		}

	}

	@Override
	public Object secondPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		HashMap<Iteration, HashMap<Character, Long>> map = new HashMap<>();

		HashMap<Character, Long> result = recursePolymerPair(map, polymerReplace, polymerTemplate.toString(), 40);

		char c = polymerTemplate.charAt(0);
		long s = result.get(c);
		result.put(c, s + 1);

		ArrayList<Long> longs = new ArrayList<>(result.values());
		Collections.sort(longs);
		System.out.println(longs);
		return longs.get(longs.size() - 1) - longs.get(0);
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("""
				NN

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 517));
		tests.add(new Test("""
				NNC

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1199));
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1588));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 2188189693529L));
	}
}
