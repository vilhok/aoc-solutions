package solutions.year2021;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day14 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder originalPolymer = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> rules = parseRules(grps);

		HashMap<CacheKey, HashMap<Character, Long>> map = new HashMap<>();

		HashMap<Character, Long> result = recursePolymer(map, rules, originalPolymer.toString(), 10);

		char c = originalPolymer.charAt(0);
		long s = result.get(c);
		result.put(c, s + 1);

		ArrayList<Long> counts = new ArrayList<>(result.values());
		Collections.sort(counts);
		return counts.get(counts.size() - 1) - counts.get(0);

	}

	@Override
	public Object secondPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder originalPolymer = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> rules = parseRules(grps);

		HashMap<Character, Long> result = recursePolymer(originalPolymer, rules);

		char c = originalPolymer.charAt(0);
		long s = result.get(c);
		result.put(c, s + 1);

		ArrayList<Long> longs = new ArrayList<>(result.values());
		Collections.sort(longs);
		return longs.get(longs.size() - 1) - longs.get(0);
	}

	private HashMap<Character, Long> recursePolymer(StringBuilder originalPolymer,
			HashMap<String, String> polymerReplace) {

		HashMap<CacheKey, HashMap<Character, Long>> cache = new HashMap<>();
		return recursePolymer(cache, polymerReplace, originalPolymer.toString(), 40);

	}

	private HashMap<String, String> parseRules(List<List<String>> grps) {
		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}
		return polymerReplace;
	}

	/**
	 * Counts how many characters exist in a specific template.
	 * @param polymerTemplate
	 * @return
	 */
	private HashMap<Character, Long> getCounts(String polymerTemplate) {
		HashMap<Character, Long> map = new HashMap<>();
		/**
		 * Would be great to parse all the available characters just once.
		 */
		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i).collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			long count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}

			map.put(c, count);
		}

		return map;

	}

	public void insertPolymers(StringBuilder og, HashMap<String, String> polymerReplace) {
		//
		record Insert(int index, String value) implements Comparable<Insert> {
			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		ArrayList<Insert> inserts = new ArrayList<>();

		for (String s : polymerReplace.keySet()) {
			int startIndex = 0;
			do {
				int next = og.indexOf(s, startIndex);
				if (next != -1) {
					inserts.add(new Insert(next + 1, polymerReplace.get(s)));
					startIndex = next + 1;
				} else {
					startIndex = next;
				}

			} while (startIndex != -1);
		}

		Collections.sort(inserts, Collections.reverseOrder());
		for (Insert ch : inserts) {
			og.insert(ch.index, ch.value);
		}
	}

	/**
	 * represent a cache entry with a specific polymer adter N rounds of iteration
	 */
	record CacheKey(String polymer, Integer afterNrounds) {

	}

	public HashMap<Character, Long> recursePolymer(HashMap<CacheKey, HashMap<Character, Long>> cache,
			HashMap<String, String> rules, String polymer, int round) {

		CacheKey piece = new CacheKey(polymer, round);

		if (cache.containsKey(piece)) {
			return cache.get(piece);
		}

		StringBuilder poly = new StringBuilder(polymer);
		insertPolymers(poly, rules);

		if (round == 1) {
			HashMap<Character, Long> h = getCounts(poly.substring(1));
			cache.put(piece, h);
			return h;
		}

		round--;

		HashMap<Character, Long> totals = new HashMap<Character, Long>();

		for (int i = 0; i < poly.length() - 1; i++) {
			String pair = poly.substring(i, i + 2);
			CacheKey segment = new CacheKey(pair, round);

			if (!cache.containsKey(segment)) {
				cache.put(segment, recursePolymer(cache, rules, pair, round));
			}

			mergeMaps(totals, cache.get(segment));
		}
		return totals;
	}

	/*
	 * adds the values from the source hashmap to the values in the destination map
	 */
	private void mergeMaps(HashMap<Character, Long> destination, HashMap<Character, Long> source) {
		for (Character c : source.keySet()) {
			Long count = source.get(c);
			Long original = destination.getOrDefault(c, 0L);
			destination.put(c, count + original);
		}

	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1588));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 2188189693529L));
	}
}
