package solutions.year2021;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day14 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		record Insert(int index, String value) implements Comparable<Insert> {

			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		long part1 = 0;

		for (int i = 0; i < 10; i++) {
			ArrayList<Insert> inserts = new ArrayList<>();

			for (String s : polymerReplace.keySet()) {
				int startIndex = 0;
				do {
					int next = polymerTemplate.indexOf(s, startIndex);
					if (next != -1) {
						inserts.add(new Insert(next + 1, polymerReplace.get(s)));
						startIndex = next + 1;
					} else {
						startIndex = next;
					}

				} while (startIndex != -1);
			}

			Collections.sort(inserts, Collections.reverseOrder());
			System.out.println("before: " + polymerTemplate);
			for (Insert ch : inserts) {
				polymerTemplate.insert(ch.index, ch.value);
//				System.out.println(ch);
			}
			System.out.println("after:  " + polymerTemplate);

		}
		return getCount(polymerTemplate);

	}

	private void recursePolymer(HashMap<Character, Long> counts, StringBuilder polymer, int round, int roundLimit) {
		if (round == roundLimit) {

		}

	}

	private long getCount(StringBuilder polymerTemplate) {
		ArrayList<Integer> counts = new ArrayList<>();

		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i).collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			int count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}
			counts.add(count);
		}

		Collections.sort(counts);
		return counts.get(counts.size() - 1) - counts.get(0);

	}

	private HashMap<Character, Long> getCounts(StringBuilder polymerTemplate) {
		HashMap<Character, Long> map = new HashMap<>();
		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i).collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			long count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}

			map.put(c, count);
		}

		return map;

	}

	@Override
	public Object secondPart(InputParser input) {
		/**
		 * Do as follows:
		 * 
		 * Recurse a single pair.<br>
		 * Check, if exists:<br>
		 * - Result set for a pair after N iterations<br>
		 * - if yes, add the counts to the totals.<br>
		 * - if no, recurse a pair<br>
		 * <br>
		 * - all that is needed should be: every pair in a hashmap, for every count. 40
		 * rounds x 100 polymer rules
		 * 
		 * 
		 * 
		 * 
		 */

		record Iteration(String polymer, Integer round) {
			
		}
		HashMap<Iteration, HashMap<Character, Long>> map = new HashMap<>();
		
		return NOT_SOLVED;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("""
				NN

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 517));
		tests.add(new Test("""
				NNC

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1199));
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1588));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 2188189693529L));
	}
}
