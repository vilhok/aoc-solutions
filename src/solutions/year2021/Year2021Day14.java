package solutions.year2021;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day14 extends DayX {

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		record Insert(int index, String value) implements Comparable<Insert> {

			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		for (int i = 0; i < 10; i++) {
			ArrayList<Insert> inserts = new ArrayList<>();

			for (String s : polymerReplace.keySet()) {
				int startIndex = 0;
				do {
					int next = polymerTemplate.indexOf(s, startIndex);
					if (next != -1) {
						inserts.add(
							new Insert(next + 1, polymerReplace.get(s)));
						startIndex = next + 1;
					} else {
						startIndex = next;
					}

				} while (startIndex != -1);
			}

			Collections.sort(inserts, Collections.reverseOrder());
			System.out.println("before: " + polymerTemplate);
			for (Insert ch : inserts) {
				polymerTemplate.insert(ch.index, ch.value);
//				System.out.println(ch);
			}
			System.out.println("after:  " + polymerTemplate);

		}
		return getCount(polymerTemplate);

	}

	private long getCount(StringBuilder polymerTemplate) {
		ArrayList<Integer> counts = new ArrayList<>();

		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i)
				.collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			int count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}
			counts.add(count);
		}

		Collections.sort(counts);
		return counts.get(counts.size() - 1) - counts.get(0);

	}

	private HashMap<Character, Long> getCounts(String polymerTemplate) {
		HashMap<Character, Long> map = new HashMap<>();
		Set<Character> chars = polymerTemplate.chars().mapToObj(i -> (char) i)
				.collect(Collectors.toSet());

		char[] polymer = polymerTemplate.toString().toCharArray();
		for (char c : chars) {
			long count = 0;
			for (char p : polymer) {
				if (c == p)
					count++;
			}

			map.put(c, count);
		}

		return map;

	}

	record Iteration(String polymer, Integer round) {

	}

	public void insertPolymers(StringBuilder og,
			HashMap<String, String> polymerReplace) {
		record Insert(int index, String value) implements Comparable<Insert> {

			@Override
			public int compareTo(Insert o) {
				return Integer.compare(this.index, o.index);
			}
		}

		ArrayList<Insert> inserts = new ArrayList<>();

		for (String s : polymerReplace.keySet()) {
			int startIndex = 0;
			do {
				int next = og.indexOf(s, startIndex);
				if (next != -1) {
					inserts.add(new Insert(next + 1, polymerReplace.get(s)));
					startIndex = next + 1;
				} else {
					startIndex = next;
				}

			} while (startIndex != -1);
		}

		Collections.sort(inserts, Collections.reverseOrder());
//		System.out.println("before: " + og);
		for (Insert ch : inserts) {
			og.insert(ch.index, ch.value);
//			System.out.println(ch);
		}
//		System.out.println("after:  " + og);
	}

	public HashMap<Character, Long> recursePolymer(
			HashMap<Iteration, HashMap<Character, Long>> map,
			HashMap<String, String> polymerReplace, String polymer,
			int roundLimit) {

		System.out.println("round " + round + " original: " + polymer);

		if (round == roundLimit) {
			Iteration piece = new Iteration(polymer, round);
			StringBuilder finalPoly = new StringBuilder(polymer);
			finalPoly.insert(1, polymerReplace.get(polymer));
			HashMap<Character, Long> h = getCounts(finalPoly.substring(1));
			System.out.println("final level, saving!");
			System.out.println(piece + " " + h + " " + finalPoly);
			map.put(piece, h);
			return h;

		}
		StringBuilder poly = new StringBuilder(polymer);
		insertPolymers(poly, polymerReplace);
		System.out.println(" Reacted:" + poly + " recursing...");
		HashMap<Character, Long> finalCounts = new HashMap<Character, Long>();

		for (int i = 0; i < poly.length() - 2; i++) {
			String s = poly.substring(i, i + 2);

			Iteration piece = new Iteration(s, roundLimit);
			if (map.containsKey(piece)) {
				System.out.println("This count was known");
				System.out.println(map.get(piece));
			} else {
				HashMap<Character, Long> ch = recursePolymer(
					map, polymerReplace, s, roundLimit - 1);
				System.out.println("piece " + piece + " completed");
				System.out.println(ch);
				;
				map.put(piece, ch);

			}
			mergeMaps(finalCounts, map.get(piece));
			System.out
					.println("Subpolymer " + s + " has result " + finalCounts);
		}
		return finalCounts;
	}

	private void mergeMaps(HashMap<Character, Long> destination,
			HashMap<Character, Long> source) {

		for (Character c : source.keySet()) {
			Long count = source.get(c);
			Long original = destination.getOrDefault(c, 0L);
			destination.put(c, count + original);
		}

	}

	@Override
	public Object secondPart(InputParser input) {
		/**
		 * Do as follows:
		 * 
		 * Recurse a single pair.<br>
		 * Check, if exists:<br>
		 * - Result set for a pair after N iterations<br>
		 * - if yes, add the counts to the totals.<br>
		 * - if no, recurse a pair<br>
		 * <br>
		 * - all that is needed should be: every pair in a hashmap, for every
		 * count. 40 rounds x 100 polymer rules
		 * 
		 * 
		 * 
		 * 
		 */
		List<List<String>> grps = input.getGroups();

		StringBuilder polymerTemplate = new StringBuilder(grps.get(0).get(0));

		HashMap<String, String> polymerReplace = new HashMap<>();

		for (String s : grps.get(1)) {
			String[] sides = s.split(" -> ");
			String result = sides[1];
			polymerReplace.put(sides[0], result);
		}

		HashMap<Iteration, HashMap<Character, Long>> map = new HashMap<>();

		HashMap<Character, Long> result = recursePolymer(
			map, polymerReplace, polymerTemplate.toString(), 3);

		char c = polymerTemplate.charAt(0);
		long s = result.get(c);
		result.put(c, s + 1);

		ArrayList<Long> longs = new ArrayList<>(result.values());
		Collections.sort(longs);
		System.out.println(longs);
		return NOT_SOLVED;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("""
				NN

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 517));
		tests.add(new Test("""
				NNC

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1199));
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 1588));

	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("""
				NN

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 2188189693529L));
		tests.add(new Test("""
				NNCB

				CH -> B
				HH -> N
				CB -> H
				NH -> C
				HB -> C
				HC -> B
				HN -> C
				NN -> C
				BH -> H
				NC -> B
				NB -> B
				BN -> B
				BB -> N
				BC -> B
				CC -> N
				CN -> C""", 2188189693529L));
	}
}
