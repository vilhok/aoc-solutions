package solutions.year2021;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

import solutions.year2021.Year2021Day19.Rotations.Matrix;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day19 extends DayX {

	// borrowed this from my other repository:
	// https://gitlab.com/vilhok/some-cube-solver/-/blob/master/src/soma/model/Rotations.java
	public class Rotations {

		public enum Matrix {
			ROT90_X(rot90x), ROT90_Y(rot90y), ROT90_Z(rot90z);

			private final int[][] matrix;

			private Matrix(int[][] matrix) {
				this.matrix = matrix;
			}

		}

		private static final int[][] rot90x = new int[][] { //
				{ 1, 0, 0 }, //
				{ 0, 0, -1 }, //
				{ 0, 1, 0 } //
		};

		private static final int[][] rot90y = new int[][] { //
				{ 0, 0, 1 }, //
				{ 0, 1, 0 }, //
				{ -1, 0, 0 } //
		};

		private static final int[][] rot90z = new int[][] { //
				{ 0, -1, 0 }, //
				{ 1, 0, 0 }, //
				{ 0, 0, 1 } //
		};

		public static int multiply(int x, int y, int z, int[] vals) {
			return (x * vals[0] + y * vals[1] + z * vals[2]);
		}

		public static void rotatePoints(ArrayList<Point3D> p, Matrix rotm) {
			int index = 0;
			for (Point3D point : p) {
				int px = point.x;
				int py = point.y;
				int pz = point.z;

				p.set(index, new Point3D(multiply(px, py, pz, rotm.matrix[0]), multiply(px, py, pz, rotm.matrix[1]),
						multiply(px, py, pz, rotm.matrix[2])));
				index++;
			}
		}
	}

	private List<Scanner> part2resultScanners;

	static record Point3D(int x, int y, int z) {

		public String toString() {
			return String.format("[%s,%s,%s]", x, y, z);
		}

		public Point3D add(Point3D diff) {

			return new Point3D(this.x + diff.x, this.y + diff.y, this.z + diff.z);
		}

		public long manhattan(Point3D o) {
			return Math.abs(this.x - o.x) + Math.abs(this.y - o.y) + Math.abs(this.z - o.z);
		}

	}

	class Vector {
		private int i;
		private int j;
		private int k;

		private Point3D p1;
		private Point3D p2;

		private Point3D unrotatedP1;
		private Point3D unrotatedP2;

		public Vector(Point3D p1, Point3D p2) {
			i = p1.x - p2.x;
			j = p1.y - p2.y;
			k = p1.z - p2.z;
			this.p1 = p1;
			this.p2 = p2;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getEnclosingInstance().hashCode();
			result = prime * result + i;
			result = prime * result + j;
			result = prime * result + k;
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Vector other = (Vector) obj;
			if (!getEnclosingInstance().equals(other.getEnclosingInstance()))
				return false;
			if (i != other.i)
				return false;
			if (j != other.j)
				return false;
			if (k != other.k)
				return false;
			return true;
		}

		private Year2021Day19 getEnclosingInstance() {
			return Year2021Day19.this;
		}

		@Override
		public String toString() {
			return "[" + i + "i, " + j + "j, " + k + "k]";
		}
	}

	class Scanner {
		// seems to be unused.
		private int scannerID;

		private ArrayList<Point3D> mutableBeacons;
		private ArrayList<Point3D> originalBeacons;
		Point3D realLocation = new Point3D(0, 0, 0);

		public Scanner(int scannerID) {
			super();
			this.scannerID = scannerID;
			mutableBeacons = new ArrayList<>();
			originalBeacons = new ArrayList<>();
		}

		public void addPoint(Point3D p) {
			if (!mutableBeacons.contains(p)) {
				mutableBeacons.add(p);
				originalBeacons.add(p);
			}
		}

		public void rotatePoints(Matrix rotM) {
			Rotations.rotatePoints(mutableBeacons, rotM);
		}

		public Set<Vector> vectorizePoints() {
			Set<Vector> v = new HashSet<>();
			for (int i = 0; i < mutableBeacons.size(); i++) {
				for (int j = i + 1; j < mutableBeacons.size(); j++) {
					Vector vec = new Vector(mutableBeacons.get(i), mutableBeacons.get(j));
					vec.unrotatedP1 = originalBeacons.get(i);
					vec.unrotatedP2 = originalBeacons.get(j);
					v.add(vec);
				}
			}
			return v;
		}

		public void resetPoints() {
			mutableBeacons = new ArrayList<>(originalBeacons);
		}

		public String toString() {
			return scannerID + " " + realLocation;
		}

	}

	public Scanner parseScanner(List<String> strs) {
		String name = strs.remove(0);
		int value = Integer.parseInt(name.split(" ")[2]);
		Scanner s = new Scanner(value);
		for (String p : strs) {
			String[] points = p.split(",");
			s.addPoint(
					new Point3D(Integer.parseInt(points[0]), Integer.parseInt(points[1]), Integer.parseInt(points[2])));
		}
		return s;
	}

	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> groups = input.getGroups();
		List<String> firstScanner = groups.remove(0);
		part2resultScanners = new ArrayList<>();
		Scanner S0 = parseScanner(firstScanner);
		part2resultScanners.add(S0);
		ArrayList<Scanner> scanners = new ArrayList<>();
		for (List<String> scanner : groups) {
			scanners.add(parseScanner(scanner));
		}

		Set<Vector> S0V = S0.vectorizePoints();
		do {
			Scanner SX = scanners.remove(0);
			if (overlaps(S0V, SX)) {

				Set<Vector> SXV = SX.vectorizePoints();

				List<MatchingPoints> mp = getMathcingPoints(S0V, SXV);
				Point3D diff = subVect(mp.get(0).originalSetPoint, mp.get(0).rotatedPoint);
				for (Point3D px : SX.mutableBeacons) {

					Point3D newpoint = px.add(diff);
					S0.addPoint(newpoint);
				}
				SX.realLocation = diff;
				part2resultScanners.add(SX);
				S0V = S0.vectorizePoints();
			} else {
				scanners.add(SX);
			}

		} while (scanners.size() > 0);
		return S0.mutableBeacons.size();
	}

	/**
	 * Do scanners have overlapping points?
	 * 
	 * @param s1 this one will be stationary
	 * @param s2 this will be rotated to every direction
	 * @return true if 12 or more common points
	 */
	public boolean overlaps(Set<Vector> original, Scanner s2) {

		// this does up to 4*4*4= 64 rotations which is inefficient. On the other hand,
		// it will stop when it finds the first.
		for (int i = 0; i < 4; i++) {
			for (int j = 0; j < 4; j++) {
				for (int k = 0; k < 4; k++) {
					s2.resetPoints();

					for (int a = 0; a < i; a++) {
						s2.rotatePoints(Matrix.ROT90_X);
					}
					for (int a = 0; a < j; a++) {
						s2.rotatePoints(Matrix.ROT90_Y);
					}
					for (int a = 0; a < k; a++) {
						s2.rotatePoints(Matrix.ROT90_Z);
					}
					Set<Vector> s2Vectors = s2.vectorizePoints();
					Set<Vector> result = sameVectors(original, s2Vectors);

					// the tasks states that 12 points overlap between scanners.
					// because scanners point sets are often merged, we might have more than 12
					// points.
					if (result.size() >= 12) {
						return true;

					}
				}
			}
		}
		return false;
	}

	private Point3D subVect(Point3D o1, Point3D o2) {
		return new Point3D(o1.x - o2.x, o1.y - o2.y, o1.z - o2.z);
	}

	public Set<Vector> sameVectors(Set<Vector> a, Set<Vector> b) {
		Set<Vector> n = a.stream().filter(b::contains).collect(Collectors.toSet());
		return n;
	}

	record MatchingPoints(Point3D originalSetPoint, Point3D rotatedPoint) {
	}

	public List<MatchingPoints> getMathcingPoints(Set<Vector> originalVectors, Set<Vector> rotatedVectors) {
		List<MatchingPoints> v1 = new ArrayList<MatchingPoints>();
		Set<Point3D> duplicates = new HashSet<>();
		for (Vector scanner0Point : originalVectors) {
			for (Vector rotatedScanner : rotatedVectors) {
				if (scanner0Point.equals(rotatedScanner) && !duplicates.contains(scanner0Point.p1)) {
					v1.add(new MatchingPoints(scanner0Point.p1, rotatedScanner.p1));
					duplicates.add(scanner0Point.p1);
				}

				if (scanner0Point.equals(rotatedScanner) && !duplicates.contains(scanner0Point.p2)) {
					v1.add(new MatchingPoints(scanner0Point.p2, rotatedScanner.p2));
					duplicates.add(scanner0Point.p2);
				}
			}
		}

		return v1;
	}

	@Override
	public Object secondPart(InputParser input) {
		if (part2resultScanners.size() == 0) {
			firstPart(input);
		}

		long distance = 0;
		for (int i = 0; i < part2resultScanners.size(); i++) {
			for (int j = i + 1; j < part2resultScanners.size(); j++) {
				Scanner s1 = part2resultScanners.get(i);
				Scanner s2 = part2resultScanners.get(j);
				long d = s1.realLocation.manhattan(s2.realLocation);
				if (d > distance) {
					distance = d;
				}
			}
		}
		return distance;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test(t1data, 79));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		// TODO: inserting tests do not work when there are fields that store the part2
		// result from part2.
//		tests.add(new Test(t1data, 3621));
	}

	String t1data = """
			--- scanner 0 ---
			404,-588,-901
			528,-643,409
			-838,591,734
			390,-675,-793
			-537,-823,-458
			-485,-357,347
			-345,-311,381
			-661,-816,-575
			-876,649,763
			-618,-824,-621
			553,345,-567
			474,580,667
			-447,-329,318
			-584,868,-557
			544,-627,-890
			564,392,-477
			455,729,728
			-892,524,684
			-689,845,-530
			423,-701,434
			7,-33,-71
			630,319,-379
			443,580,662
			-789,900,-551
			459,-707,401

			--- scanner 1 ---
			686,422,578
			605,423,415
			515,917,-361
			-336,658,858
			95,138,22
			-476,619,847
			-340,-569,-846
			567,-361,727
			-460,603,-452
			669,-402,600
			729,430,532
			-500,-761,534
			-322,571,750
			-466,-666,-811
			-429,-592,574
			-355,545,-477
			703,-491,-529
			-328,-685,520
			413,935,-424
			-391,539,-444
			586,-435,557
			-364,-763,-893
			807,-499,-711
			755,-354,-619
			553,889,-390

			--- scanner 2 ---
			649,640,665
			682,-795,504
			-784,533,-524
			-644,584,-595
			-588,-843,648
			-30,6,44
			-674,560,763
			500,723,-460
			609,671,-379
			-555,-800,653
			-675,-892,-343
			697,-426,-610
			578,704,681
			493,664,-388
			-671,-858,530
			-667,343,800
			571,-461,-707
			-138,-166,112
			-889,563,-600
			646,-828,498
			640,759,510
			-630,509,768
			-681,-892,-333
			673,-379,-804
			-742,-814,-386
			577,-820,562

			--- scanner 3 ---
			-589,542,597
			605,-692,669
			-500,565,-823
			-660,373,557
			-458,-679,-417
			-488,449,543
			-626,468,-788
			338,-750,-386
			528,-832,-391
			562,-778,733
			-938,-730,414
			543,643,-506
			-524,371,-870
			407,773,750
			-104,29,83
			378,-903,-323
			-778,-728,485
			426,699,580
			-438,-605,-362
			-469,-447,-387
			509,732,623
			647,635,-688
			-868,-804,481
			614,-800,639
			595,780,-596

			--- scanner 4 ---
			727,592,562
			-293,-554,779
			441,611,-461
			-714,465,-776
			-743,427,-804
			-660,-479,-426
			832,-632,460
			927,-485,-438
			408,393,-506
			466,436,-512
			110,16,151
			-258,-428,682
			-393,719,612
			-211,-452,876
			808,-476,-593
			-575,615,604
			-485,667,467
			-680,325,-822
			-627,-443,-432
			872,-547,-609
			833,512,582
			807,604,487
			839,-516,451
			891,-625,532
			-652,-548,-490
			30,-46,-14""";
}
