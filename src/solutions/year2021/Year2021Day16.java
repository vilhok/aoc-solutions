package solutions.year2021;

import java.math.BigInteger;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2021Day16 extends DayX {

	class Token {
		int version;
		Operation type;

		int tokenStart;
		int tokenEnd;

		long literal;

		int subtokenCount;

		int subTokenEnd;

		public Token(int version, int type) {
			super();
			this.version = version;
			this.type = Operation.values()[type];
		}

		public int version() {
			return version;
		}

		@Override
		public String toString() {
			return "Token [version=" + version + ", type=" + type
					+ ", tokenStart=" + tokenStart + ", tokenEnd=" + tokenEnd
					+ ", literal=" + literal + ", subtokenCount="
					+ subtokenCount + ", subTokenEnd=" + subTokenEnd + "]";
		}
	}

	class ExprTree {

		Node root;

		public ExprTree(ArrayDeque<Token> tokens) {
			root = fromToken(tokens.poll());
			root.build(tokens);
		}

		public Node fromToken(Token t) {
			System.out.println(t);
			return switch (t.type) {
			case GT, LT, EQ -> new BinaryNode(t);
			case LITERAL -> new LiteralNode(t);
			case SUM, PRODUCT, MIN, MAX -> new MultiNode(t);
			};

		}

		public long value() {
			return root.value();
		}

		abstract class Node {
			Operation op;
			Token token;

			public Node(Token t) {
				this.op = t.type;
				this.token = t;
			}

			public abstract long value();

			public abstract void build(Deque<Token> t);

			public abstract int maxEnd();

		}

		class BinaryNode extends Node {

			Node left;
			Node right;

			public BinaryNode(Token t) {
				super(t);
			}

			/**
			 * Guaranteed to have exactly 2 children
			 */
			public void build(Deque<Token> tokens) {
				left = fromToken(tokens.poll());
				left.build(tokens);
				right = fromToken(tokens.poll());
				right.build(tokens);
			}

			/**
			 * Reports the node that is futhest away in the string
			 * representation
			 */
			public int maxEnd() {
				if (left == null && right == null) {
					return token.tokenEnd;
				} else if (right == null) {
					return left.maxEnd();
				}
				return Integer.max(right.maxEnd(), left.maxEnd());
			}

			/*
			 * Resolve this binary operator
			 */
			public long value() {
				switch (op) {
				case GT: {
					return left.value() > right.value() ? 1 : 0;
				}
				case LT: {
					return left.value() < right.value() ? 1 : 0;
				}
				case EQ: {
					return left.value() == right.value() ? 1 : 0;
				}
				default:
					throw new RuntimeException("invalid operation");
				}

			}
		}

		class MultiNode extends Node {
			ArrayList<Node> children;

			public MultiNode(Token t) {
				super(t);
				children = new ArrayList<>();
			}

			public void build(Deque<Token> tokens) {
				if (token.subtokenCount > 0) {
					// build child nodes until a specific count is reached
					while (this.children.size() != token.subtokenCount) {
						Node n = fromToken(tokens.poll());
						this.children.add(n);
						n.build(tokens);
					}
				} else {
					//build tokens until a childnode is at the end the subTokenEnd value
					do {
						Node n = fromToken(tokens.poll());
						n.build(tokens);
						children.add(n);
					} while (maxEnd() < token.subTokenEnd);
				}
			}

			public int maxEnd() {
				if (children.size() == 0) {
					return token.tokenEnd;
				}
				int mx = token.tokenEnd;
				for (Node n : children) {
					int max = n.maxEnd();
					if (max > mx) {
						mx = max;
					}
				}
				return mx;
			}

			public long value() {
				switch (op) {
				case MIN:
					return children.stream().mapToLong(Node::value).min()
							.getAsLong();
				case MAX:
					return children.stream().mapToLong(Node::value).max()
							.getAsLong();
				case SUM:
					return children.stream().mapToLong(Node::value).sum();
				case PRODUCT:
					return children.stream().mapToLong(Node::value)
							.reduce(1, (a, b) -> a * b);
				default:
					//for getting rid of the warning.
					throw new RuntimeException("invalid operation");

				}

			}
		}

		class LiteralNode extends Node {

			public LiteralNode(Token t) {
				super(t);
				this.value = t.literal;
			}

			public void build(Deque<Token> tokens) {
				// nop
			}

			long value;

			public long value() {
				return value;
			}

			public int maxEnd() {
				return token.tokenEnd;
			}
		}

	}

	enum Operation {
		SUM, PRODUCT, MIN, MAX, LITERAL, GT, LT, EQ;

	}

	@Override
	public Object firstPart(InputParser input) {
		ArrayList<Token> tokens = parseNodes(input);
		tokens.forEach(System.out::println);
		return tokens.stream().mapToInt(Token::version).sum();
	}

	private ArrayList<Token> parseNodes(InputParser input) {
		String origin = input.string();
		String s = new BigInteger(input.string(), 16).toString(2);
		while (s.length() != origin.length() * 4) {
			s = "0" + s;
		}
		ArrayList<Token> tokens = new ArrayList<>();
		for (int i = 0; i < s.length();) {
			if (s.length() - i <= 10)
				break;

			int version = Integer.parseInt(s.substring(i, i + 3), 2);
			int type = Integer.parseInt(s.substring(i + 3, i + 6), 2);

			Token t = new Token(version, type);
			t.tokenStart = i;
			if (type == 4) {
				i = insertLiteral(s, t, i + 6);

			} else {
				i += 6;
				int lType = s.charAt(i) == '1' ? 1 : 0;
				i++;
				if (lType == 1) {
					int value = Integer.parseInt(s.substring(i, i + 11), 2);
					t.subtokenCount = value;
					i += 11;
				} else {
					int value = Integer.parseInt(s.substring(i, i + 15), 2);
					t.subTokenEnd = t.tokenStart + value + 6 + 15;
					i += 15;
				}
			}
			t.tokenEnd = i - 1;
			tokens.add(t);
		}
		return tokens;
	}

	/**
	 * Parses a literal from the data and inserts it to a given token.
	 * 
	 * @param data
	 * @param target
	 * @param startindex
	 * @return what is the new index after the parsing.
	 */
	public int insertLiteral(String data, Token target, int startindex) {
		int current = startindex;
		int end = 0;
		StringBuilder literal = new StringBuilder();
		while (data.charAt(current) != '0') {
			end = current + 5 < data.length() ? current + 5 : data.length();
			literal.append(data.substring(current + 1, end));
			current += 5;
		}
		end = current + 5 < data.length() ? current + 5 : data.length();
		literal.append(data.substring(current + 1, end));
		current += 5;

		long l = Long.parseLong(literal.toString(), 2);
		target.literal = l;
		return end;
	}

	@Override
	public Object secondPart(InputParser input) {
		ArrayDeque<Token> tokens = new ArrayDeque<>(parseNodes(input));
		ExprTree tree = new ExprTree(tokens);
		return tree.value();
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("D2FE28", 6));
		tests.add(new Test("8A004A801A8002F478", 16));
		tests.add(new Test("620080001611562C8802118E34", 12));
		tests.add(new Test("C0015000016115A2E0802F182340", 23));
		tests.add(new Test("A0016C880162017C3686B18A3D4780", 31));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("C200B40A82", 3));
		tests.add(new Test("04005AC33890", 54));
		tests.add(new Test("880086C3E88112", 7));
		tests.add(new Test("CE00C43D881120", 9));
		tests.add(new Test("D8005AC2A8F0", 1));
		tests.add(new Test("F600BC2D8F", 0));
		tests.add(new Test("9C005AC2F8F0", 0));
		tests.add(new Test("9C0141080250320F1802104A08", 1));
	}
}
