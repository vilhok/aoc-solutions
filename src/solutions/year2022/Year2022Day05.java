package solutions.year2022;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2022Day05 extends DayX {

	static String PATTERN = "move (.*) from (.*) to (.*)";

	
	public void move(Deque<Character> source, Deque<Character> target, int count) {
		for (int i = 0; i < count; i++) {
			target.push(source.pop());
		}
	}
	
	public void moveStack(Deque<Character> source, Deque<Character> target, int count) {
		ArrayList<Character> toMove = new ArrayList<>();
		for (int i = 0; i < count; i++) {
			toMove.add(source.pop());
		}
		Collections.reverse(toMove);
		for (Character c : toMove) {
			target.push(c);
		}
		
	}
	
	@Override
	public Object firstPart(InputParser input) {
		List<List<String>> in = input.getGroups();

		List<Deque<Character>> stacks = parseInintial(in);
		Pattern p = Pattern.compile(PATTERN);
		for (String line : in.get(1)) {
			Matcher m = p.matcher(line);
			m.find();
			int count = Integer.parseInt(m.group(1));
			int source = Integer.parseInt(m.group(2)) - 1;
			int target = Integer.parseInt(m.group(3)) - 1;
			move(stacks.get(source), stacks.get(target), count);
			
		}

		String sol = "";
		for (Deque<Character> stack : stacks) {
			sol += stack.pop();
		}
		return sol;
	}

	private List<Deque<Character>> parseInintial(List<List<String>> in) {
		List<Deque<Character>> stacks = new ArrayList<>();

		List<String> initial = in.get(0);
		Collections.reverse(initial);
		initial.remove(0); // headers

		for (String line : initial) {
			int stackId = 0;
			for (int i = 1; i < line.length(); i += 4) {
				char crate = line.charAt(i);

				if (stacks.size() == stackId) {
					stacks.add(new ArrayDeque<Character>());
				}

				if (crate != ' ')
					stacks.get(stackId).push(crate);
				
				stackId++;
			}
		}
		return stacks;
	}



	@Override
	public Object secondPart(InputParser input) {
		List<List<String>> in = input.getGroups();

		List<Deque<Character>> stacks = parseInintial(in);
		Pattern p = Pattern.compile(PATTERN);
		for (String line : in.get(1)) {
			Matcher m = p.matcher(line);
			m.find();
			int count = Integer.parseInt(m.group(1));
			int source = Integer.parseInt(m.group(2)) - 1;
			int target = Integer.parseInt(m.group(3)) - 1;
			moveStack(stacks.get(source), stacks.get(target), count);
			
		}

		String sol = "";
		for (Deque<Character> stack : stacks) {
			sol += stack.pop();
		}
		return sol;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test(test, "CMZ"));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {

	}

	String test = """
			    [D]
			[N] [C]
			[Z] [M] [P]
			 1   2   3

			move 1 from 2 to 1
			move 3 from 1 to 3
			move 2 from 2 to 1
			move 1 from 1 to 2""";

}
