package solutions.year2018;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2018Day08 extends DayX {

	private class Node {
		private int childCount;
		private int[] metadata;
		private int start;
		private int end;
		private int metalen;

		private ArrayList<Node> children;

		public Node(int childcount, int start, int metalength) {
			this.start = start;
			this.childCount = childcount;
			this.metalen = metalength;
			this.children = new ArrayList<>();
			metadata = new int[metalength];
		}

		public int getNodeValuePart2() {
			if (childCount == 0) {
				return Arrays.stream(metadata).sum();
			} else {
				return Arrays.stream(metadata).filter(i -> i > 0 && i <= childCount)
						.map(i -> children.get(i - 1).getNodeValuePart2()).sum();
			}
		}

		public int getEnd() {
			return end;
		}

		public void build(int[] input, int depth) {
			while (children.size() != childCount) {

				int nextChildOffset = children.size() == 0 ? start + 2
						: children.stream().max((a, b) -> Integer.compare(a.getEnd(), b.getEnd())).get().end + 1;

				Node nextChild = parseNode(nextChildOffset, input);
				children.add(nextChild);

				if (nextChild.childCount == 0) {
					nextChild.end = nextChild.start + nextChild.metalen + 1;

				}
				nextChild.build(input, depth + 1);
			}

			int childEnd = children.size() == 0 ? start + 1
					: children.stream().max((a, b) -> Integer.compare(a.getEnd(), b.getEnd())).get().end;
			this.end = childEnd + metalen;
			int metastart = childEnd + 1;

			System.arraycopy(input, metastart, metadata, 0, metalen);
			return;

		}

		public int traverseMetaSum() {
			int thissum = Arrays.stream(metadata).sum();
			if (this.childCount == 0) {
				return thissum;
			} else {
				return thissum + children.stream().mapToInt(Node::traverseMetaSum).sum();
			}
		}


		public Node parseNode(int startIndex, int[] table) {
			int directChildren = table[startIndex];
			int metalength = table[startIndex + 1];
			return new Node(directChildren, startIndex, metalength);
		}

		public String toString() {
			return start + "," + end;
		}
	}

	/**
	 * Not really that useful class
	 */
	class HeaderTree {
		private Node root;

		public HeaderTree(int[] input) {
			this.root = getRoot(0, input);
			root.build(input, 1);
		}

		public Node getRoot(int startIndex, int[] table) {
			int directChildren = table[startIndex];
			int metalength = table[startIndex + 1];
			return new Node(directChildren, startIndex, metalength);
		}
		public int getRootNodeValue() {
			return root.getNodeValuePart2();
		}
	}

	@Override
	public Object firstPart(InputParser parser) {
		int[] input = parser.asSingleIntArray();
		HeaderTree ns = new HeaderTree(input);
		return ns.root.traverseMetaSum();
	}

	@Override
	public Object secondPart(InputParser parser) {
		int[] input = parser.asSingleIntArray();
		HeaderTree ns = new HeaderTree(input);

		return ns.getRootNodeValue();
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2", 138));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {
		tests.add(new Test("2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2", 66));
	}
}
