package solutions.year2015;

import java.util.Arrays;
import java.util.List;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.github.aoclib.api.InputParser;
import com.github.aoclib.solver.DayX;

/**
 * <p>
 * AUTOGENERATED BY DayGenerator.java
 * </p>
 *
 * <p>
 * https://github.com/vilhok/aoc-lib
 * </p>
 *
 * <p>
 * Edits in this file will not be overwritten.
 * </p>
 *
 */
public class Year2015Day15 extends DayX {
	String regex = "(.*): capacity (.*), durability (.*), flavor (.*), texture (.*), calories (.*)";

	long part2 = 0;

	record Ingredient(String name, int capacity, int durability, int flavor, int texture, int calories) {
		int[] getMultiplies(int x) {
			return new int[] { x * capacity, x * durability, x * flavor, x * texture, x * calories };
		}
	}

	public Ingredient parseIngeredient(String s) {
		Matcher m = Pattern.compile(regex).matcher(s);
		System.out.println(s);
		m.matches();
		MatchResult mr = m.toMatchResult();
		return new Ingredient(mr.group(1), Integer.parseInt(mr.group(2)), Integer.parseInt(mr.group(3)),
				Integer.parseInt(mr.group(4)), Integer.parseInt(mr.group(5)), Integer.parseInt(mr.group(6)));
	}

	@Override
	public Object firstPart(InputParser input) {
		part2 = 0;
		List<Ingredient> ingredients = input.getLines(this::parseIngeredient);
		long total = 0;
		for (int a = 0; a <= 100; a++) {
			for (int b = 0; b <= 100 - a; b++) {
				for (int c = 0; c <= 100 - a - b; c++) {
					next:
					for (int d = 0; d <= 100 - a - b - c; d++) {
						if (a + b + c + d != 100) {
							continue;
						}
						int[] multiples = { a, b, c, d };

						long[] result = new long[4];
						int calories = 0;
						for (int i = 0; i < ingredients.size(); i++) {
							int[] values = ingredients.get(i).getMultiplies(multiples[i]);
							for (int k = 0; k < 4; k++) {
								result[k] += values[k];
							}
							calories += values[4];
						}
						for (int k = 0; k < 4; k++) {
							if (result[k] <= 0) {
								continue next;
							}
						}

						long score = Arrays.stream(result).reduce(1, (f, s) -> f * s);

						if (calories == 500) {

							if (score > part2) {
								part2 = score;
							}
						}
						if (score > total) {
							total = score;
						}
					}
				}
			}
		}
		return total;
	}

	@Override
	public Object secondPart(InputParser input) {
		if (part2 == 0) {
			firstPart(input);
		}
		return part2;
	}

	/*
	 * Optional: add tests for each part in the following methods
	 *
	 * These methods have blank implementations in superclass as well and can be
	 * deleted if you don't want to include tests.
	 *
	 * Add test as follows:
	 *
	 * new Test("sampleinput", expectedSolution);
	 *
	 * Collect the tests from the task web page.
	 */

	@Override
	protected void insertTestsPart1(List<Test> tests) {
		tests.add(new Test("""
				Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
				Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3""", 62842880));
	}

	@Override
	protected void insertTestsPart2(List<Test> tests) {

	}
}
